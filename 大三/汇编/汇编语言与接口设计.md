>ssr整理
>
>lbw于2022.12针对一些地方做出补充，由于22-23第一学期是线上开卷考试只有选择题，所以一些考不大到的我就没写，希望学弟学妹们未来可以补充
>
>加*的是重点

# Chapter 1 微型计算机硬件系统

## 微处理器

### 性能指标

1. 主频

   又称主时钟频率，表示CPU内数字脉冲信号振荡的速度

2. 外频

   系统总线的工作频率，也是CPU与周边设备传输数据的频率

3. 倍频

   CPU和系统总线之间工作频率相差的倍数

$$
主频 = 外频 \times 倍频
$$

前端总线(FSB)是处理器到北桥之间的总线
$$
FSB数据带宽 = (总线频率\times数据位宽) \div 8
$$
但是随着内存控制器的出现，北桥被淘汰，FSB也随之消失

### 软件特性

#### 工作模式

实模式、保护模式、虚拟实模式

#### 指令系统

复杂指令集：CISC指令集，如AMD、VIA、x86-64等

精简指令集：RISC指令集



## 主板

主板是微型机各种硬件的载体

### 芯片组

芯片组用于控制局部总线和各种扩展卡，芯片组一开始由南桥芯片与北桥芯片组成，因为北桥的很多功能模块被集合进cpu内部所以北桥渐渐消失，芯片组也演变成CPU+南桥的单芯片组体系结构模式，称为平台控制器集线器(PCH)

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221016145332034.png" alt="image-20221016145332034" style="zoom:25%;" />

南桥芯片主要负责I/O总线之间的通信，如PCI总线、USB、LAN、ATA、SATA、音频管理器、键盘控制器、实时时钟控制器、高级电源管理等

#### BIOS芯片

BIOS：Basic Input Output System，包含一组例行程序，由他们来完成系统与外设之间的输入输出工作，同时其中还包含自检程序

#### CMOS芯片

CMOS记录了系统的一些重要信息，使用RAM保存，由CMOS电池保持供电

### 多通道内存技术

采用多通道内存同时连接多条内存时**相当于提高了内存带宽**

> 假定2条DDR 400内存条，工作在 200MHz频率下，每个时钟可以传送2次64位数据。双通道系统中内存总线的总带宽为?
> $$
> 2\times(2\times64)\times200 Mbit/s=3.2GB/s
> $$

### 插件插槽

cpu、内存、电源、PCI和PCIE、IDE与SATA、机箱跳线等



## *内存

### 基本概念

内存存放当前正在执行的程序和使用的数据

数据：

1. bit：一个二进制位，0或1
2. byte：字节，8比特长
3. 字：16位两个字节长
4. 双字：32位四个字节长
5. 四字：64位八个字节长

一般来说，Intel系列的cpu都采用==小端方案==存储数据，即低字节在低地址，高字节在高地址，比如双字的存储：

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221016225655729.png" alt="image-20221016225655729" style="zoom: 67%;" />

可以看到低字节存储在前高字节存储在后





# Chapter 2 微处理器管理模式

## 微处理器基本结构

80386处理器包含总线接口单元、中央处理单元和存储器管理单元三大部分

### 总线接口单元 BIU

总线接口单元负责CPU与存储器和外设之间的信息传送，执行单元执行程序指令，并进行算术逻辑运算等

具体的，它会从存储器中预取指令、读写数据；从I/O接口读写数据及其他控制功能

### 中央处理单元 CPU

CPU由指令部件和执行部件组成

#### 指令部件

指令部件包含指令预取单元IPU和指令译码单元IDU两个部分

##### 指令预取单元IPU

负责从存储器中取出指令，存放到一个16字节的FIFO指令队列中

##### 指令译码单元IDU

负责执行从已译码指令队列中取出的指令，包含8个32位通用寄存器、1个32位算术逻辑单元ALU和一个64位的桶形移位器和乘除硬件

### 存储管理单元MMU

由分段部件和分页部件组成，分别实现段式存储管理与保护模式下的分页模型

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221016232602462.png" alt="image-20221016232602462" style="zoom: 67%;" />



## *CPU工作模式

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221016233257910.png" alt="image-20221016233257910" style="zoom:67%;" />

### 实模式

复位时自动进入实模式，完全以8086的方式运行。**DOS操作系统**运行在实模式下

- 使用**1MB**地址空间和**16位**“段首址 : 偏移”地址格式

- 不支持硬件上多任务切换，不支持特权级，可执行所有特权命令

### 保护模式

通过**修改控制寄存器CR0的控制位PE**实现实模式到保护模式的切换。linux、windows运行在保护模式下

1. 支持多任务和==4个特权级==，最高为0（操作系统），最低为3（应用程序）
2. 支持内存分页机制，提供段式和页式内存管理
3. 物理寻址空间达到4GB
4. 虚拟地址空间可达64TB

### V86模式

又称V86模式，是为了在Windows、linux中执行Dos程序设计的，是经过"修改"的保护模式

1. 兼容8086程序
2. 以任务的形式在保护模式上执行
3. 采用模拟的方法实现特权指令

## *寄存器

本课程介绍的80386使用6个16位的寄存器(CS, DS, SS, ES, GS, FS)和32位通用寄存器(EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP)

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221018174421701.png" alt="image-20221018174421701" style="zoom:50%;" />

### 程序可见寄存器

#### 通用寄存器

| 寄存器 |                 常用功能                 | 32 位 | 16位 | 8位   |
| ------ | :--------------------------------------: | ----- | ---- | ----- |
| RAX    | 累加器，乘法、除法运算等指令的专用寄存器 | EAX   | AX   | AH,AL |
| RBX    |        保存数据，可用作基址寄存器        | EBX   | BX   | BH,BL |
| RCX    |             保存数据，计数值             | ECX   | CX   | CH,CL |
| RDX    | 保存数据，乘法、除法运算指令的专用寄存器 | EDX   | DX   | DH,DL |
| RBP    |       保存访问存储单元时的偏移地址       | EBP   | BP   | -     |
| RDI    |        用于寻址串指令的目的操作数        | EDI   | DI   | -     |
| RSI    |         用于寻址串指令的源操作数         | ESI   | SI   | -     |

#### 专用寄存器

1. IP/EIP

   指向程序的下一条指令

2. SP/ESP

   指向栈顶满单元

##### 标志寄存器 eFlags

用于指示微处理器的状态并控制它的操作

80386的32位EFLAG寄存器：<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221019140158161.png" alt="image-20221019140158161" style="zoom:50%;" />

- CF：==进位标志==，位于D0

  当结果产生一个进位或错位，CF=1，否则CF=0；在移位或循环移位指令时，会把左移时的最高位或右移时的最低为移入CF

- ZF：==零标志==，位于D6

  当运算结果为0时，ZF为1，否则为0

- SF：==符号标志==，位于D7

  与运算结果的最高位相同

- OF：==溢出标志==，位于D11
  有符号数运算时，当运算结果超出了表达的范围时，OF=1，否则OF=0

#### 段寄存器

实模式和V86模式下，段寄存器内保存的是20位**段首址的高16位**，段首址的低4位为0

在保护模式下，段寄存器中的16位内容是一个**段选择符**，用于在段表述符表中选择段描述符

- 代码段寄存器 ==CS==：存放代码的一段存储区

- 数据段寄存器 ==DS==：存放供程序使用的数据的一段存储区

- 堆栈段寄存器 ==SS==：存放用作堆栈的存储区

- 附加段寄存器 ==ES==：存放一段附加的数据段

### 保护模式下的寄存器
#### 控制寄存器

80386中有4个系统控制寄存器CR0, CR1, CR2, CR3，如图所示：

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221019152729957.png" alt="image-20221019152729957" style="zoom:50%;" />

CR0的第0位的PE是保护模式允许标志，0为实模式，1为保护模式。软件通过设置PE可以进入或退出保护模式

#### 全局描述符表寄存器 GDTR

全局描述符表GDT是用来定义全局存储空间的一种机制，他用段描述符来描述一个全局存储中的段。**一个描述符8字节**，每个GDT最多含有8192个描述符

GDTR是48位的寄存器：最低16位是限长，给出GDT的字节大小(比GDT的长度少1)；高32位是基址，指出GDT在内存中存放的基地址

![image-20221019153408783](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221019153408783.png)



>已知GDTR=0E003F0003FFH，则全局描述符表的基址是多少？这个全局描述符表有多大，里面有多少个描述符？
>
>基址为0E003F00H，大小为400H，可以包含400H/8=128个描述符

#### 局部描述符表寄存器 LDTR

LDT定义的是**某项任务用到的局部存储器的地址空间**，多任务环境下每个任务都有自己的LDT

LDT由LDTR确定，LDTR是**16位的选择符**，包含LDT描述符在GDT中的索引，LDT描述符指出LDT的位置和大小

使用LDTR确定LDT的位置和限长的过程：

1. 先用GDTR获取GDT表在存储器中的位置和限长
2. 再用LDTR在GDT中取出LDT描述符
3. 根据LDT描述符获取LDT的位置和限长

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221217203837948.png" alt="image-20221217203837948" style="zoom:50%;" />

#### 中断描述符表寄存器 IDTR

中断描述符表IDT中保存**中断门描述符**，每个门描述符包含**8字节**；IDT最多包含**256个门描述符**，因为CPU最多支持**256个中断**

IDTR是48位的寄存器：最低16位是限长，给出中断描述符表IDT的字节大小(比IDT的长度少1)；高32位是基址，指出IDT在内存中存放的基地址

![image-20221019154450124](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221019154450124.png)

#### 任务寄存器 TR

**16位选择符**，在保护模式的任务切换机制中使用；作用是在GDT中检索出TSS描述符，每一个任务都有一个任务状态段TSS，由TSS描述符(8字节)描述

#### 段选择符

上面提到，段寄存器在实模式、V86模式和保护模式下的内容不同。在**保护模式**下，段寄存器不会存放段基址，而是会存放一个索引，称为==段选择符==。使用这个段选择符从GDT或LDT找到一个8字节长的**段描述符**，从而得知这个段的信息

![](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221019164123556.png)

1. RPL：请求特权级

2. TI：表指示符，为0时从GDT中查找；为1时从LDT中查找

3. Index：索引，指出要访问的描述符在描述符表中的**顺序号**


>假定LDT的基址为00120000H，GDT基址为00100000H。如 果装入CS寄存器的选择符为1007H，那么请求特权级是多少？段描述符地址是多少？描述符在GDT还是LDT里面 获得？

## *内存管理

### 实模式分段管理

在实模式下，段基址必须定位在地址为**16的整数倍**，并且段长不能超过64K。最大可寻址空间为**1MB**

物理地址的计算方法（段基址存放在段寄存器）：
$$
物理地址 = 10H \times 段基址+偏移量
$$
|        操作类型        | 约定段寄存器 | 允许指定的段寄存器 | 偏移量 |
| :--------------------: | :----------: | :----------------: | :----: |
|          指令          |      CS      |         无         |   IP   |
|        堆栈操作        |      SS      |         无         |   SP   |
|        普通变量        |      DS      |     ES, SS, CS     |   EA   |
|  字符串指令的源串地址  |      DS      |     ES, SS, CS     |   SI   |
| 字符串指令的目标串地址 |      ES      |         无         |   DI   |
|    BP用作基址寄存器    |      SS      |     DS, ES, CS     |   EA   |

### 保护模式分段管理

在保护模式下可以使用分段基址访问**4GB的内存空间**或使用分页机制访问16TB的虚拟存储器

#### 段描述符

==段描述符==用于描述代码段、数据段和堆栈段，如图：

![image-20221019171843139](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221019171843139.png)

可知段描述符长8字节，由32位的段基址、20位限长、8位访问权限和4位的属性组成：

- 段基址：32位
- 限长：20位
- 访问权限：8位
  - **P**：存在位，为1表示已经装入内存
  - **DPL**：描述符特权级，取值为0-3
  - **S**：描述符类型位，为0时表示是系统段描述符
  - **E**：可执行位，为1时表示是代码段后两位为C和R；为0时表示时数据段或堆栈段，后两位为ED和W
  - C：代码段特有，一致位，为1时表示是一致代码段
  - R：代码段特有，读允许位，为1时表示读允许
  - ED：数据段或堆栈段特有，扩展方向位，为1表示地址从高到低扩展
  - W：数据段或堆栈段特有，写允许位，为1表示允许写入
  - **AVL**：访问位，为1表示被访问过
- 属性：4位
  - **G**：粒度位，为1时表示限长以页为单位，为0表示以字节为单位
  - **D**：默认操作数宽度，为1表示32位数据操作段，为0表示16位
  - **AVL**：可用位

#### 段式地址转换

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221019174600498.png" alt="image-20221019174600498" style="zoom:50%;" />

- 虚拟地址：程序指令中使用的地址，由段、偏移两部分组成

- 线性地址：线性地址为32位，同一虚拟地址可能得到不同的线性地址

- 物理地址：物理地址是微处理器引脚输出的地址信号，CPU分页部件负责线性地址和物理地址的转换


### 页式内存管理

保护模式下CPU支持分页机制，并且他将分段管理机制得到的线性地址转换为物理地址。分页机制可以只把每个活动任务当前所必需的少量页面放在内存中。说人话就是**把段再细分成了一个个页**，按需装入内存

#### 线性地址转换成物理地址

分页机制就是一种将线性地址的页面映射到物理地址页面的手段，要注意一个线性页面映射到一个物理页面，但是多个线性页面可以映射到同一个物理页面上。分页机制需要用到两个表：==页表目录表==和==页表==

线性地址：

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221019175345935.png" alt="image-20221019175345935" style="zoom:50%;" />

1. 记得前面控制寄存器有个CR3为页目录基址寄存器，其高20位为页表目录表的基址，配合线性地址高10位的索引即可找到页目录
2. 找到页目录之后根据线性地址中间的10位也就是页表索引，从页表目录表中找到具体的页表
3. 之后用低12位的字节索引找到页表中的页描述符
4. 根据页描述符找到具体页面

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221019175725302.png" alt="image-20221019175725302" style="zoom:50%;" />

#### 页表项

页表项就是上文中所提到的**页表描述符**与**页描述符**，都是32位，格式如图：

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221019175845846.png" alt="image-20221019175845846" style="zoom:50%;" />

#### 片内转换检测缓冲器 TLB

TLB中保存了最近使用过的32个页描述符，可以提高线性地址到物理地址的转换效率

## 任务

任务是指完成某功能的多个程序的集合，系统中至少存在一个任务。任务以分时的方式使个程序轮流执行。保护模式下，任何时刻都有一个当前任务，由**TR寄存器**指定。

每个任务由两部分组成

- 任务执行环境TES：任务执行环境包括一个代码段、堆栈段和数据段等，任务在每一个特权级上执行时都有一个堆栈段

- 任务状态段TSS：104个字节，保存了任务的各种状态信息，可以实现任务的挂起和回复，在任务切换过程中起重要作用。

  TSS描述符属于系统描述符，S位等于0，必须放在GDT表中，其类型位Type值为1001或1011，1011表示该任务正在执行，1001表示被挂起

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210619134522976.png" alt="image-20210619134522976" style="zoom:50%;" />

### 门

一种转换机构，可以实现不同特权级别之间的控制传送

门描述符属于系统描述符，其格式为

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210619135451870.png" alt="image-20210619135451870" style="zoom:50%;" />

- 调用门：用于控制传送，改变任务或者程序的特权级别。类型为4或C时表示调用门

- 任务门：用于执行任务切换，任务门内的选择符必须只是GDT中的TSS描述符

- 中断门和陷阱门：用来指出中断服务程序的入口地址

### 任务切换

四种情况

- 执行远程JMP或者CALL指令，选择了GDT中的TSS描述符
- 执行远程JMP或者CALL指令，从GDT或者LDT中选择了任务门
- 发生了中断或异常，中断向量选择了IDT中的任务门
- 当FLAGS 中的NT=1时，执行IRET指令，目的任务选择符在执行IRET任务的TSS链接域中

任务切换可以分为

- 直接任务切换

  <img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210619140236767.png" alt="image-20210619140236767" style="zoom:50%;" />

  要求TSS的$DPL\ge MAX(CPL，RPL)$

- 间接任务切换

  <img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210619140312746.png" alt="image-20210619140312746" style="zoom:50%;" />

  要求Gate的$DPL\ge MAX(CPL,RPL)$

任务切换的步骤为

1. 把寄存器现场保存到当前任务的TSS（任务A的TSS）
2. 把指示目标任务（任务B）TSS的选择符装入TR寄存器中，同时把对应TSS的描述符装入TR的高速缓冲寄存器中
3. 恢复当前任务（任务B）的寄存器现场
4. 进行链接处理
5. 把CR0中的TS标志置为1，这表示已发生过任务切换，在当前任务使用协处理器指令时，产生故障（向量号为7）
6. 把TSS中的CS选择符的RPL作为当前任务特权级，设置为CPL
7. 装载LDTR寄存器
8. 装载代码段寄存器CS、堆栈段寄存器SS和各数据段寄存器及其高速缓冲寄存器

## 保护

保护模式下设置了0，1，2，3四个特权级，阻止了非法访问

### 数据访问的保护

程序访问某段并将选择DS前，将会与段描述符进行验证

- 存在检查：P位如果为0表示还未装入主存

- 段类型是否一致：目标段的类型是否与待操作段寄存器类型一致，此外，读写操作也存在限制

- 限长检查：保护模式下段的长度可变，所以CPU要利用段描述符中给出的限长来防止程序的存储器寻址超出段边界

- 特权级检查：CPU在加载段选择符入段寄存器时，先检查特权级，决定是否允许程序访问这个段

  要求：$DPL ≥ MAX(CPL, RPL)$

  - ==DPL==：描述符特权级，位于描述符中
  - ==CPL==：CS寄存器的最低两位
  - ==RPL==：请求特权级

  <img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210619141703867.png" alt="image-20210619141703867" style="zoom:50%;" />

### 对程序的保护

#### 直接转移的保护

同一代码段**内部转移时只需要检查限长**

段间转移时，检查限长、特权级CPL和DPL：

- CPL=DPL，允许跳转和调用
- CPL<DPL，禁止。高特权级不能转移到低特权级
- CPL>DPL，此时要检查段描述符的C位。如果C位为1，表示这是一致代码段,允许跳转和调用

一致代码段是指操作系统用于**共享的代码段**，被调用时特权级与调用者保持一致，转移前后CPL不变

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210619142316609.png" alt="image-20210619142316609" style="zoom: 50%;" />

非一致性代码段是指操作系统保护的系统代码段，只能允许特权级相同的程序间访问

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210619142258450.png" alt="image-20210619142258450" style="zoom:50%;" />

#### 间接转移的保护

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210619142552850.png" alt="image-20210619142552850" style="zoom:50%;" />

需要满足两个条件

- $DPL_{gate} \ge MAX(CPL,RPL)$
- $DPL_{code} \le CPL$

### 对输入输出的保护

CPU采用**I/O特权级IOPL**和**TSS段中I/O许可位图**的方法来控制输入/输出，实现输入/输出保护





# Chapter 3 指令系统

## *数据寻址方式

- CPU操作数寻址
  1. 立即寻址
  2. 寄存器寻址
- 存储器操作数寻址
  1. 直接寻址
  2. 寄存器间接寻址
  3. 寄存器相对寻址
  4. 基址变址寻址
  5. 相对基址变址寻址
  6. 比例变址寻址

数据传送指令：`MOV  DST,SRC`

### CPU操作数寻址

参与计算的操作数来自CPU内部

#### 立即寻址

操作数直接包含在指令中，紧跟在操作码之后

```assembly
MOV	BL,9		# BL = 9
MOV	EAX,1234H	# EAX = 1234H
```

#### 寄存器寻址

操作数直接包含在寄存器中，由指令指定寄存器的寻址方式

寄存器可以是8位、16位、32位通用寄存器或16位段寄存器(但CS不能用于目标)

默认使用DS所指向的数据段，但BP、EBP和ESP默认使用SS

```assembly
MOV BX, AX
MOV AX, ES : VER
```

### 存储器操作数寻址

参与计算的操作数来自存储器

| 操作类型               | 约定段寄存器 | 允许指定的段寄存器 | 偏移量 |
| ---------------------- | ------------ | ------------------ | ------ |
| 指令                   | CS           | 无                 | IP     |
| 堆栈操作               | SS           | 无                 | SP     |
| 普通变量               | DS           | ES, SS, CS         | EA     |
| 字符串指令的源串地址   | DS           | ES, SS, CS         | SI     |
| 字符串指令的目标串地址 | ES           | 无                 | DI     |
| BP用作基址寄存器       | SS           | DS, ES, CS         | EA     |

#### 直接寻址

操作数的**有效地址**直接包含在指令中，操作数保存在内存中

```assembly
MOV EAX, [00404011H]
MOV	EAX, VAR		# VAR是一个内存变量名，代表一个内存单元的符号地址
```

#### 寄存器间接寻址

操作数的有效地址保存在在寄存器中，而操作数在存储器中

```assembly
MOV AL,[BX]
MOV AL,ES:[78H]
MOV AX,[BP]	# BP在默认情况下与SS配合
```

#### 寄存器相对寻址

操作数的有效地址是一个寄存器的内容和指令中给定的一个位移量的和

- 对于16位寻址，这个寄存器只能是BX、BP或SI、DI
- 对于32位寻址，可以使用任何通用寄存器

```assembly
MOV AL,8[BX]
MOV EDI,[ESI+4]
```

#### 基址变址寻址

操作数的有效地址是一个基址寄存器和一个变址寄存器的内容之和

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210620135543535.png" alt="image-20210620135543535" style="zoom:33%;" />

```assembly
MOV AL, [BX] [SI]	# (DS:[BX+SI]) to AL
```

#### 相对基址变址寻址

操作数的有效地址是一个基址和一个变址寄存器的内容和指令中给定的一个位移量之和

```assembly
MOV AL, ARY[BX] [SI]	#(DS:[BX+SI+ARY]) to AL
```

#### 比例变址寻址方式

操作数的有效地址由以下几部分相加组成：基址、变址乘以比例因子(1 2 4 8)、位移量

```assembly
MOV EBX,[EBP+ECX*4+10H]
```



## *数据运算指令

### 数据传送指令

除了目的地址为标志寄存器的传送之外，其他指令不影响标志

#### 传送指令MOV

格式：`MOV  DST,SRC`

功能：SRC（源）→DST（目标）

注意：源操作数目标操作数类型必须匹配，传送方向必须遵循以下规则

- 立即数不能作为目标操作数
- 立即数不能直接送段寄存器
- 目标寄存器不能是CS
- 两个段寄存器间不能直接传送
- 两个存储单元之间不能直接传送

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221217094035066.png" alt="image-20221217094035066" style="zoom:50%;" />

对于立即数传送到存储单元中的情况，必须进行**类型显示说明**：`MOV    WORD PTR[BX],10`

此外，MOV还可以实现地址传送，借助`SEG`和`OFFSET`操作符

- `MOV AX,SEG TAB`：把TAB的**段基址**送给AX寄存器

- `MOV DI,OFFSET TAB`：把TAB的**偏移量**送给DI寄存器

#### 带扩展的传输指令

- 带符号扩展的传送指令`MOVSX`
- 带零扩展的传送指令`MOVZX`

#### 堆栈操作指令

- `PUSH`

  格式：`PUSH  SRC`

  功能：ESP = ESP - 2/4，SS:ESP = (SRC)

  注意：在80286以上的机器中，SRC还可以是立即数。

- `POP`

  格式：`POP  DST`

  功能：(DST) = SS:ESP，ESP = ESP + 2


#### 交换指令XCHG

格式：`XCHG  OPR1,OPR2`

功能：交换两个操作数。两个操作数都不能是立即数，其中之一必须是寄存器操作数

#### 输入输出指令

- `IN`

  格式：`IN  ACR,PORT`

  功能：把外设端口（PORT）的内容传送给累加器（ACR）

  注意：累加器为AL、AX、EAX，对应8位、16位、32位数据

- `OUT`

  格式：`OUT  PORT,AC`

  功能：把累加器的内容传送给外设端口

若端口号小于等于255，则直接使用立即数；若大于255，则将端口号保存在DX中，用DX间接寻址

#### 地址传送指令LEA

格式：`LEA REG,SRC`

功能：把源操作数的有效地址送给指定的寄存器

注意：REG必须是寄存器，SRC必须是存储器操作数

#### 标志传送指令

- `PUSHF`，`PUSHFD`

  功能：`PUSHF`将FLAGS标志寄存器压入栈，`PUSHFD`将EFLAGS标志寄存器压入栈

- `POPF`，`POPFD`

  功能：`POPF`把栈中数据弹到FLAGS标志寄存器，`POPFD`把栈中数据弹到EFLAGS标志寄存器

两个POP指令会影响标志位，其他不影响

### 算数运算指令

#### 类型转换指令

这类指令实际上就是把操作数的最高位进行扩展

- 字节扩展成字指令`CBW`

  功能：AL寄存器的符号位值扩展到AH中

- 字扩展成双字指令`CWD`

  功能：AX寄存器中的符号位值扩展到DX中

- 双字扩展四字指令`CDQ`

  功能：EAX寄存器中的符号位值扩展到EDX中

- AX符号位扩展EAX指令`CWDE`

  功能：AX寄存器中的符号位值扩展到EAX的高16位中

#### 二进制加法指令

- 加法指令`ADD`

  格式：`ADD  DST,SRC`

  功能：（DST）＋（SRC）→ DST

  注意：对操作数的限定同MOV指令

  标志：影响OF、SF、ZF、AF、PF、CF标志

  - **无符号数**相加若使CF置1，表示溢出
  - **带符号数**相加结果若使OF置1，表示溢出

- 带进位加法指令`ADC`

  格式:`ADC  DST,SRC`

  功能:（DST）＋（SRC）＋CF → DST

  注意，该指令适用于多字节或多字的加法运算

  影响OF、SF、ZF、AF、PF、CF标志

- 加1指令`INC`

  格式：`INC  DST`

  功能：（DST）＋1→DST

  注意，不影响CF标志位，影响OF、SF、ZF、AF、PF

#### 二进制减法指令

- 减法指令`SUB`

  格式：`SUB  DST,SRC`

  功能：(DST)－(SRC)→ DST

- 带借位减法指令`SBB`

  格式:：`SBB  DST,SRC`

  功能:：(DST)－(SRC)－CF → DST

  该指令适用于多字节或多字的减法运算

- 减1指令`DEC`

  格式：`DEC  DST`

  功能：(DST)－1→DST
  
- 求补指令`NEG`

  格式：`NEG DST`

  功能：对目标操作数求反加1，并把结果送回目标，即0-(DST)→DST

  影响标志位OF、SF、ZF、AF、PF、CF，对CF和OF的影响如下：

  - 对操作数能表示的最小负数求补，源操作数不变，OF置一
  - 源操作数为0，CD清0
  - 对非0操作数求补后，CF置1

#### 比较指令CMP

格式：`CMP  DST,SRC`

功能:(DST)－(SRC)，影响标志位OF、SF、ZF、AF、PF、CF

#### 乘法指令

- 无符号乘法指令`MUL`

  格式：`MUL  SRC`

  功能：实现两个**无符号**二进制数乘。

  注意，该指令只含一个源操作数，不能是立即数，另一个乘数必须事前放在累加器中。可以实现8位、16位、32位无符号数乘

  - 字节型乘法：(AL)×(SRC)8→AX
  - 字型乘法：(AX)×(SRC)16→DX:AX
  - 双字型乘法：(EAX)×(SRC)32→EDX:EAX

  若乘积的高半部分为0，CF和OF清0，否则都置1

- 带符号乘法指令`IMUL`

  格式1：`IMUL  SRC`，若乘积的高半部分为低半部分的符号扩展，则对CF和OF清0，否则置1

  格式2：`IMUL  REG,SRC`，REG和SRC的长度必须相同，REG为目标；若乘积能完全放入目标寄存器则对CF和OF清0，否则置1

#### 除法指令

- 无符号除法指令 `DIV`

  格式：`DIV  SRC`

  功能：实现两个无符号二进制数除法

  该指令只含一个源操作数，该操作数作为除数使用，注意它不能是立即数。被除数必须事前放在隐含的寄存器中。

  - 字节型除法：(AX)/(SRC)8→商AL,余数AH
  - 字型除法：(DX:AX)/(SRC)16→商AX,余数DX
  - 双字型除法：(EDX:EAX)/(SRC)32→商EAX,余数EDX

- 带符号除法指令IDIV

### 逻辑运算指令

| 名称     | 格式             | 功能        | 标志                   |
| -------- | ---------------- | ----------- | ---------------------- |
| 逻辑非   | `NOT DST`        | DST按位取反 | 不影响                 |
| 逻辑与   | `AND DST,SRC`    | DST&SRC     | 清零CF和OF，影响SF、ZF |
| 测试     | `TEST OPR1,OPR2` | OPR1&OPR2   | 同上                   |
| 逻辑或   | `OR DST,SRC`     | DST\|SRC    | 同上                   |
| 逻辑异或 | `XOR DST,SRC`    | DST^SRC     | 同上                   |

### 移位指令

- 逻辑移位：无符号数
- 算数移位：带符号数

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210620152125042.png" alt="image-20210620152125042" style="zoom: 80%;" />

- 循环移位
- 带进位的循环移位

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210620152503344.png" alt="image-20210620152503344" style="zoom: 80%;" />

## *程序控制指令

### 转移指令

#### 转移指令的寻址方式

格式：`JMP 目标`

功能：无条件转移到目标处

目标的寻址方式可以分为：

- 段内转移

  只影响指针IP值

  - 段内直接转移

    - 短转移

      位移量为8位，格式：`JMP SHORT LAB  `

    - 近转移

      位移量为16/32位，格式：`JMP LAB` 或 `JMP NEAR PTR LAB`

  - 段内间接转移

    <img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210620153748481.png" alt="image-20210620153748481" style="zoom:50%;" />

- 段间转移

  影响IP和CS

  需要双字变量或6字节变量，变量由偏移量和段基址组成，注意是逆序存放

  - 段间直接转移

    格式：`JMP FAR PTR LAB`

  - 段间间接转移

    格式：`JMP DWORD PTR [BX]`

    用一个双字内存变量中的低16位取代IP值，高16位取代CS值
    
    该双字变量的地址可以由除立即寻址和寄存器寻址方式以外的其它与数据有关的寻址方式获得

#### 条件转移指令

注意条件转移指令**只能段内转移**

- 检测单个条件标志位转移指令表

  |        汇编格式 |         功能         | 测试条件 |
  | --------------: | :------------------: | :------: |
  |      `JC LABEL` |      有进位转移      |  CF＝1   |
  |     `JNC LABEL` |      无进位转移      |  CF＝0   |
  |      `JO LABEL` |       溢出转移       |  OF＝1   |
  |     `JNO LABEL` |      无溢出转移      |  OF＝0   |
  |  `JP/JPE LABEL` |        偶转移        |  PF＝1   |
  | `JNP/JPO LABEL` |        奇转移        |  PF＝0   |
  |      `JS LABEL` |       负数转移       |  SF＝1   |
  |     `JNS LABEL` |      非负数转移      |  SF＝0   |
  |   `JZ/JE LABEL` |   结果为0/相等转移   |  ZF＝1   |
  | `JNZ/JNE LABEL` | 结果不为0/不相等转移 |  ZF＝0   |
  
- 根据两个**带符号数**比较结果实现转移的条件转移指令
  
  |        汇编格式 |        功能         |     测试条件      |
  | --------------: | :-----------------: | :---------------: |
  | `JG/JNLE LABEL` | 大于/不小于等于转移 | ZF＝0 and  SF＝OF |
  | `JNG/JLE LABEL` | 不大于/小于等于转移 |  ZF＝1 or  SF≠OF  |
  | `JL/JNGE LABEL` | 小于/不大于等于转移 |       SF≠OF       |
  | `JNL/JGE LABEL` | 不小于/大于等于转移 |      SF＝OF       |
  
- 根据两个无符号数比较结果实现转移的条件转移指令
  
  |            汇编格式 |        功能         |    测试条件     |
  | ------------------: | :-----------------: | :-------------: |
  |     `JA/JNBE LABEL` | 高于/不低于等于转移 | CF＝0 and ZF＝0 |
  |     `JNA/JBE LABEL` | 不高于/低于等于转移 | CF＝1 or ZF＝1  |
  |  `JB/JNAE/JC LABEL` | 低于/不高于等于转移 |      CF＝1      |
  | `JNB/JAE/JNC LABEL` | 不低于/高于等于转移 |      CF＝0      |

#### 循环指令LOOP

格式：`LOOP  LABEL`

功能：(CX)－1→CX，若(CX)≠0，则转向标号处执行循环体，否则顺序执行下一条指令。

#### 子程序指令

  - 调用指令`CALL`

    格式：`CALL  DST`

    功能：调用子程序。执行时先把返回地址压入堆栈，再形成子程序入口地址，最后把控制权交给子程序。

    与JMP的相同点

    - 段内直接／间接调用、段间直接／间接调用、

    与JMP的不同点

    - CALL转移后要返回，所以要保存返回地址；
    - JMP转移后不再返回,所以不必保存返回地址。

  - 返回指令`RET`

    格式1：`RET`

    功能：按照CALL指令入栈的逆序，从栈顶弹出返回地址（弹出一个字到IP，若子程序是FAR型还需再弹出一个字到CS），然后返回到主程序继续执行。

    格式2：`RET imm16`

    功能：按照CALL指令入栈的逆序，从栈顶弹出返回地址（弹出一个字到IP，若子程序是FAR型还需再弹出一个字到CS）,返回到主程序，并修改栈顶指针SP＝(SP)＋imm16。

    注意：修改堆栈指针是为了废除堆栈中主程序传递给子程序的参数。

#### 中断指令

  中断就是使计算机暂时挂起正在执行的进程而转去处理某种事件，处理完后再恢复执行原进程的过程。

  对某事件的处理实际上就是去执行**中断子程序**。

  中断向量是中断处理子程序的入口地址，FAR类型

  中断类型号是中断类型的编号，共计256种

  中断向量表，中断类型号与中断向量的对应关系，详细内容在第9章

  - `INT `

    格式：`INT  n`；n为中断类型号

    功能：中断当前正在执行的程序，把当前的FLAGS、CS、IP值依次压入堆栈(保护断点）,并从中断向量表的4n处取出n类中断向量.

  - `IRET`

    格式：`IRET`

    功能：从栈顶弹出三个字分别送入IP、CS、FLAGS寄存器,把控制返回到原断点继续执行。

## 处理机控制指令

### 标志操作指令

直接对CF、DF、IF进行操作，指令中前缀CL，ST，CM分别意为清零、置一和取反

| 汇编格式 |        功能         | 影响标志 |
| :------: | :-----------------: | :------: |
|  `CLC`   |   把进位标志CF清0   |    CF    |
|  `STC`   |   把进位标志CF置1   |    CF    |
|  `CMC`   |  把进位标志CF取反   |    CF    |
|  `CLD`   |   把方向标志DF清0   |    DF    |
|  `STD`   |   把方向标志DF置1   |    DF    |
|  `CLI`   | 把中断允许标志IF清0 |    IF    |
|  `STI`   | 把中断允许标志IF置1 |    IF    |

### 其它处理机控制指令

- `NOP`：空操作
- `HLT`：停机
- `WAIT`：等待
- `LOCK`：使总线锁定信号有效

## 块操作指令

重要性存疑



# Chapter 4 汇编语言程序开发

## *汇编语言基本知识

- 机器语言
- 汇编语言
- 高级语言

MASM汇编器、LINK链接器、汇编链接步骤

汇编语句分类：

1. 指令
2. 伪指令
3. 宏指令

## 常用伪指令

### 数据定义伪指令

```assembly
;格式：[变量名] 助记符 操作数，例如：
M1	DB	0ABH
```

功能：为变量分配单元，并为其初始化或者只预留空间

| 类型   | 简写 | 数据类型 | 字节数 |
| ------ | ---- | -------- | ------ |
| BYTE   | DB   | 字节     | 1      |
| WORD   | DW   | 字       | 2      |
| DWORD  | DD   | 双字     | 4      |
| QWORD  | DQ   | 四字     | 8      |
| FWORD  | DF   | 六字节   | 6      |
| TBYTE  | DT   | 十字节   | 10     |
| SBYTE  |      | 有符号数 | 1      |
| SWORD  |      | 有符号数 | 2      |
| SDWORD |      | 有符号数 | 4      |

操作数类型

- 数字常量与数值表示

  二进制数以b结尾，八进制数以Q或O结尾，十六进制数以H结尾，若第1位为字母，则必须加0

- 字符串常量：用单引号括起来如`M2 DB '15','AB$`

- 地址表达式：操作数可以是地址符号，保存其偏移量，如`M3 DW M2`

- ？：预留空间不赋值

- `<n> dup(操作数,...)`：重复多次括号内的数据，如`M4 DB 2 DUP(5,'A')`

### 符号定义伪指令

#### 等值伪指令 EQU

`符号名 EQU 表达式`

功能：用符号名代表任何的有效操作数，但是`EQU`定义的符号在同一个程序不能重复定义

`EQU`配合`$`可以计算字符串长度

#### 等号伪指令

`符号名 = 数值表达式`

功能：用符号名代替数值表达式的值，表达式只能是常数或数值表达式，可以重复定义

### 操作符伪指令

- `$`操作符

  功能：$在程序中表示**当前地址计数器**的值，既可以是指令的地址，也可以是变量的偏移量。程序中一般用它来计算变量占用的空间

- `ORG`操作符

  格式：`ORG 数值表达式`

  功能：设置地址计数器内容为数值表达式的值

- `OFFSET`操作符
  格式：`OFFSET [变量|标号] `
  功能：`OFFSET`操作符用来取出变量或标号的地址（在段中的偏移量）。在32位编程环境中，地址是一个32位的数。

- 算术操作符

  $+~-~*~/~MOD$等，计算在编译时完成

- 逻辑操作符

  AND、OR、XOR、NOT

- 关系操作符

  - EQ：等于；NE：不等于
  - LT：小于；LE：小于等于
  - GT：大于；GE：大于等于

### 框架定义伪指令

微处理器伪指令，指明使用哪一种CPU的指令集

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210620165419759.png" alt="image-20210620165419759" style="zoom: 67%;" />

框架定义伪指令

| 伪指令格式                                | 功能                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| .DATA                                     | 定义数据段                                                   |
| .DATA?                                    | 定义存放未初始化变量的数据段                                 |
| .CONST                                    | 定义存放常量的数据段                                         |
| .CODE                                     | 定义代码段                                                   |
| .STARTUP                                  | 指定加载后的程序入口点                                       |
| .EXIT                                     | 返回DOS或父进程                                              |
| .STACK size                               | 建立一个堆栈段并定义其大小（size以字节为单位。若不指定size参数，则使用默 认值1 KB）。 |
| .MODEL 内存模式\[,调用规则\]\[,其他模式\] | 定义程序工作的模式                                           |

## 汇编源程序格式

### 控制台界面

```assembly
;模式定义
.386
.model flat,stdcall
option casemap:none

;库文件及函数声明
includelib msvcrt.lib
printf	PROTO C :ptr sbyte,:VARARG ;或者使用include
scanf PROTO C :dword,:vararg

;数据部分
.data
szMsg	byte	'Hello World',0ah,0

;代码部分
.code
start:
	invoke printf, offset szMsg
	ret
end start
```

### *Windows界面

```assembly
;模式定义
.386
.model flat.stdcall
option casemap:none
;库文件及函数声明
includelib user32.lib
MessageBoxA PROTO stdcall :dword,:dword,:dword,:dword 
MessageBox equ <MessageBoxA>
;数据部分
.data
SzTitle	byte	'Hi!'
SzMsg	byte	'Hello World',0
;代码部分
.code
start:
	invoke MessageBox,
		   NULL,
		   offset szMsg,
		   offset szTitle,
		   MB_OK
	ret
end start
```

## *分支和循环程序设计

只要写过汇编代码或者是做过Bobm lab这里应该就很明确了，不专门整理

### 分支程序设计

- IF_THEN_ELSE结构

  <img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221216205857600.png" alt="image-20221216205857600" style="zoom:50%;" />

- SWITCH_CASE结构：需要使用==跳转表==

### 循环程序设计

- DoWhile
- DoUntil

循环程序要包含：循环初始化、循环体、循环控制部分

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221216210016474.png" alt="image-20221216210016474" style="zoom:50%;" />

折半查找算法：<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221216205841489.png" alt="image-20221216205841489" style="zoom:50%;" />

## *浮点运算

### 浮点数表示与存储

|   格式   |                           说明                           |
| :------: | :------------------------------------------------------: |
|  单精度  |    32位：1位符号位，8位阶码，23位为有效数字的小数部分    |
|  双精度  |   64位：1位符号位，11位阶码，52位为有效数字的小数部分    |
| 扩展精度 | 80位：1位符号位，15位阶码，1位为整数部分，63位为小数部分 |

### 浮点寄存器

FPU不适用通用寄存器，使用自己的一组寄存器称为==寄存器栈==，为**8个**独立寻址的**80位**寄存器。编号为0-7，命名为ST(0)-ST(7)，它是一个向下扩展的循环栈，栈顶指针指向ST(0)：

![image-20221216210956835](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221216210956835.png)

工作原理：

1. 当程序需要向寄存器栈中装入数据的时候，栈顶指针减1，然后将数据压入**栈顶指针指向的寄存器**
2. 当栈顶指针指向的地址值为0时，下一次入栈操作则将地址压入地址值为7的浮点寄存器中，栈顶指针地址值为7
3. 当需要将寄存器栈中的数据保存到内存中时，则进行出栈操作，出栈操作与入栈操作相反
4. 使用浮点寄存器时，其名称为ST(i)，其中的i不是寄存器的地址，而是**距离栈顶的长度**

举例：

```assembly
; 一些定义省略
.data
	szMsg byte "%f", 0ah, 0
	a real8 3.2
	b real8 2.6
	m real8 7.1
	f real8 ?
.code
start:
	finit ;finit为FPU栈寄存器的初始化
	fld m ;fld为浮点值入栈
	fld b
	fmul st(0),st(1) ;fmul为浮点数相乘，结果保存在目标操作数中
	fld a
	fadd st(0),st(1) ;fadd为浮点数相加，结果保存在目标操作数中
	fst f ;fst将栈顶数据保存到内存单元
	invoke printf, offset szM,f
```



另有3个16位寄存器分别为：

- 标志寄存器：每两位构成一个tag对应一个浮点寄存器，tag的不同值标记浮点寄存器的不同状态：00为有效，01为数据为0，10为数据NaN、INF或非规格化、11对应空
- 状态寄存器：表明浮点处理单元的各种状态
- 控制寄存器：用于控制浮点处理单元的异常屏蔽、精度及舍入操作

### 浮点指令

- 数据定义，注意在定义浮点数时不能出现纯整数形式，**一定要有小数点**

  - dd(dword)/32位/REAL4：定义单精度浮点数
  - dq(qword)/64位/REAL8：定义双精度浮点数
  - dt(tbyte)/80位/REAL10：定义扩展精度浮点数

- 浮点寻址方式

  - 寄存器寻址：操作数保存在指定的数据寄存器栈中，用ST(i)表示。
  - 存储器寻址：操作数在内存中，内存中的数据可以采用与数据有关的存储器寻址方式访问。

- 浮点指令

  太多了，而且课本上都有，懒得再整理了

## 程序优化

它说的这些优化的方法/思想在csapp中都有提到，而且这次开卷考试，懒得整理了













# Chapter 5 子程序设计

## *子程序基本知识

定义方式

```assembly
子程序名	PROC	   [类型]
		   ……
		   RET
子程序名	ENDP
```

设计注意点：

- 寄存器的保存与恢复
- 保持堆栈平衡
- 子程序说明

### 堆栈

堆栈，就是供程序使用的一块连续的内存空间，一般用于保存和读取临时性的数据

1. 特点

   - 临时性
   - 快速性
   - 动态扩展性

2. 作用

   - 保护或恢复现场

   - 变量之间数据传递

   - 临时数据区

   - 子程序的调用与返回

     Call指令保存返回地址到堆栈中，RET指令从堆栈中取出返回地址

     子程序的局部变量也在堆栈中，程序参数传递也可以使用堆栈


## *参数传递

参数传递有三个方式：

1. 通过寄存器传递
2. 通过数据区变量传递
3. 通过堆栈传递

### C函数常见传递方式

| 调用规则 | 参数入栈顺序                           | 参数出栈 | 说明                   |
| :------- | :------------------------------------- | -------- | ---------------------- |
| cdecl    | 从右至左                               | 主程序   | 参数个数可动态变化     |
| stdcall  | 从右至左                               | 子程序   | Windows API常使 用     |
| fastcall | 用ECX、EDX传递1、2个参数，其余从右至左 | 子程序   | 常用于内核程序         |
| this     | ECX等于this，从右至左                  | 子程序   | C++成员函数使用        |
| naked    | 从右至左                               | 子程序   | 自行编写进入/退 出代码 |

- cdecl方式

  使用[EBP+X]访问参数，例：[EBP+8]代表第一个参数，[EBP+12]代表第二个参数

  子程序使用RET指令返回，在主程序中执行`ADD ESP,N`来平衡堆栈，N为参数个数乘4

- stdcall方式

  堆栈平衡由子函数完成，使用`RET n`指令，n为参数个数乘4

- fastcall方式

  类似于stdcall方式，但是使用ecx传递第一个参数，edx传递第2个参数

- naked方式

  不会生成函数进入和退出代码（push ebp等）

### 带参子函数的调用

- 可以使用前面提到的C函数调用的原则，做好参数转换与堆栈平衡然后用`call`指令调用
- 也可以使用MASM提供的`INVOKE`伪指令

```assembly
; 子函数定义
ExampleProc1	proc	stdcall a:dowrd	;使用stdcall规则，一个参数a
	mov	eax,a							; 使用参数a
	ret				
ExampleProc1	endp
; 主函数
ExampleProc2	proc
	INVOKE	ExampleProc1,20				;调用子函数并传递参数a=20
ExampleProc2	endp
```

`INVOKE`伪指令伪指令后面跟的参数必须能够直接作为PUSH指令的源操作数

### 局部变量

在子程序内部使用，在进入子程序时，通过修改堆栈指针ESP来预留出需要的空间；在返回主程序之前恢复ESP来释放

可以使用`LOCAL`伪指令定义，并且必须紧接在子程序定义伪指令`PORC`之后

```assembly
;格式：LOCAL 变量名1[重复数量][:类型], 变量名2[重复数量][:类型]……
LOCAL TEMP[3]:DWORD
LOCAL TEMP1,TEMP2:DWORD
```

## 子程序的特殊应用

### 子程序嵌套

嵌套深度取决于堆栈容量，需要维持堆栈的平衡

### 子程序递归

### 缓冲区溢出

当程序向缓冲区内写入的数据超过了缓冲区的容量，缓冲区之外的内存单元被程序“非法”修改。



## 模块化程序设计

### 模块间通信方式

由于各个模块需要单独汇编，于是就会出现当一个模块通过名字调用另一模块中的子程序或使用其数据时，这些名字对于调用者来讲是**未定义**的，因此在汇编过程中就会出现符号未定义错误，可以用以下伪指令来解决：

- 外部引用伪指令`EXTRN`

  格式：`EXTRN/EXTERN  变量名:类型 [,…]`
  `EXTERN result:dword`

  说明本模块中用到的变量是另一个模块中定义的

- 全局符号说明伪指令`PUBLIC`

  格式：`PUBLIC  名字 [,…]`
  `public	result`

  说明本模块中定义的名字可以被其他模块使用，名字可以是变量名可以是子程序名

- 子程序声明伪指令`PROTO`

  格式：`子程序名  PROTO  [C | stdcall] :[第一个参数类型] [,:后续参数类型]`
  `printf  PROTO C :dword,:vararg`

![image-20221216180652650](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221216180652650.png)



## *C语言程序的反汇编

《计导》(csapp)第三章和Bomb Lab里面讲的反汇编秒杀这里的，就不整理了

## 混合编程

### 直接嵌入

内嵌汇编语句中的操作数可以是寄存器、局部变量、全局变量及函数参数、结构成员

```c
_asm 汇编语言
_asm{
    ...
}
```

### C程序调用汇编子程序

### 汇编调用C函数

C语言函数加`extern`关键字，汇编程序中`PROTO`定义



# Chapter 6 存储系统与技术

## 高速缓冲存储器 Cache

Cache是位于CPU和主存之间的临时存储器，一般由高速SRAM构成

### *Cache工作原理

#### 局部性原理

1. 时间局部性
2. 空间局部性

#### Cache访问结构

1. 贯通查找式 Look Through

   $cache平均访问时间 = cache访问时间+(1-命中率)×未命中时主存访问时间$

   降低了CPU对主存的请求次数，但是不命中时延迟了CPU对主存的访问

   ![image-20221214192445585](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221214192445585.png)

2. 旁路读出式 Look Aside

   $cache平均访问时间 = 命中率×cache访问时间+(1-命中率)×未命中时主存访问时间$

   不命中时速度更快，但是CPU每次请求都会发给主存，CPU总线占用率高X

   ![image-20221214192452230](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221214192452230.png)

#### Cache映射

主存和Cache之间交换数据的单位是==数据块==，其大小固定

- 全相联映射

  ![image-20221214193411202](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221214193411202.png)

- 直接相联映射

- 组相联映射

#### Cache替换策略

当主存的一个块要调入Cache中时，要做如下考虑：

1. 若Cache中有空行，直接放入空行
2. 若Cache中没有空行，则应按某种算法替换一行，常见算法有随机、FIFO、LRU

#### 微机中的Cache

- L1 cache
- L2 cache
- L3 cache
- 追踪缓存 ETC

### Cache一致性

**写Cache**的过程因为涉及到对内容的修改，存在导致Cache内容和对应内存内容不一致的可能性

#### Cache写策略

- 未命中时数据直接写入内存，然后决定是否再调入Cache中
- 命中时：
  1. 直写式 Write Through：立即把数据写入内存
  2. 回写式 Write Back：不立即写入内存，并且为每一行设置一个==标志位==示意更改是否更新到内存；当该行被替换时，必须先写入内存

#### 多核CPU的MESI协议

1. **M**odified修改
2. **E**xclusive独占
3. **S**hared共享
4. **I**nvalid无效

只有当缓存段处于**E或M状态**时，处理器才能执行写操作

## 内部存储器

### 内存分类

![image-20221214200955913](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221214200955913.png)

#### RAM

- 双极型：存取速度高，成本高，用作Cache
- MOS型：
  1. SRAM：不需要刷新
  2. DRAM：需要刷新

#### ROM

- MROM
- PROM：1次编程
- EPROM：多次编程
- Flash

### 技术指标和参数

#### 存储容量

$$
存储单元容量=行数\times列数\times数据深度(位宽)\times L-Bank数量
$$

128M**bit**内存芯片的布局：

|        布局         | 每bank存储单元数 | 位宽 | Bank数 | 行地址 |  列地址   |
| :-----------------: | :--------------: | :--: | :----: | :----: | :-------: |
| $8M\times4\times4$  |        8M        |  4   |   4    | A0~11  | A0~9、A11 |
| $4M\times8\times4$  |        4M        |  8   |   4    | A0~11  |   A0~9    |
| $2M\times16\times4$ |        2M        |  16  |   4    | A0~11  |   A0~8    |

#### 内存带宽

内存带宽是内存的数据传输速度，是衡量内存的重要指标
$$
带宽=总线宽度\times总线频率\times一个时钟周期内交换的数据包个数
$$

- 当内存使用DDR时，一个时钟周期交换两个数据包
- 总线宽度如果不特意提，就默认64位

#### 其他

1. 存储器访问：
   - 存储周期：连续两次存储器请求所需的最短间隔
   - 访存时间：存储器从接收命令到被读出信息稳定输出的时间间隔
2. 错误校验：
   - 奇偶校验 Parity
   - ECC

### 内存模组

#### 接口

1. SIMM
2. DIMM

#### SDRAM

同步动态随机存储器(Synchronous DRAM)，**内存与系统总线速度同步**，只在时钟上沿进行数据传输

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221214232119621.png" alt="image-20221214232119621"  />

#### *DDR

DDR可以在时钟的上升和下降沿各进行一次数据传输

读入时DQS信号由DDR芯片驱动

## 辅助存储器

### HDD

MBR保存在0磁头0柱面1扇区
$$
平均访问时间=平均寻道时间+平均潜伏时间+数据读取时间
$$

### 扇区编址

#### CHS

对于一个$N$个盘面的磁盘：

1. 他有$2N$个面，对应$2N$个磁头(Heads)，编号为$0,1,2...,nH$
2. 每个盘片上相同编号的磁道形成柱面(Cylinders)，编号为$0,1,2...,nC$
3. 每个磁道又被分为多个扇区(Sector)，编号为$0,1,2...,nS$

![image-20221214233901087](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221214233901087.png)

那么使用一个三元组$<C,H,S>$就可以定位任意扇区

CHS编址带来的容量上限：

![image-20221214234034591](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221214234034591.png)

#### LBA

因为CHS编址容量上限小，所以引入LBA编址：

- 28位的LBA可支持：$2^{28}×512=128GB$
- 48位的LBA理论上可支持的硬盘容量就达到了$2^{48}×512=128PB$

#### 编址转换

- $L=[(C\times nH+H)\times nS]+S-1$
- $S=(L\%nS)+1$，$H=(L\div nS)\%nH$，$C=(L\div nS)\div nH$

### SATA

串行ATA，采用差分方式传输，采用了全速命令队列技术NCQ

#### NCQ技术

支持NCQ技术的硬盘在接到读写指令后，根据指令对访问地址进行重新排序，减少读取时间，使数据传输更为高效，同时也能有效延长硬盘的使用寿命



# Chapter 7 总线技术

## 总线分类

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221214235148776.png" alt="image-20221214235148776"  />
$$
总线带宽=总线频率\times总线位宽\div8
$$

## PCI总线

- 采用地址线与数据线复用方式
- 独立于处理器，工作频率与处理器基准频率无关

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215124455557.png" alt="image-20221215124455557" style="zoom:50%;" />

## PCI-E总线

- 每个设备都有自己的专用连接，不需要向整个总线请求带宽
- 数据传输率更高

## USB总线

USB(Universal Serial Bus)，通用串行总线

| USB版本      | 速率                |
| ------------ | ------------------- |
| USB 1.1, 2.0 | 12Mb/s  或  1.5MB/s |
| USB 2.0      | 480Mb/s             |
| USB 3.0      | 5Gb/s               |



![image-20221215125239207](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215125239207.png)

## $I^2C$总线

两线式串行总线



# Chapter 8 接口技术

接口模块包括

- 控制端口：接受CPU指令
- 状态端口：提供状态信息给CPU
- 数据端口：匹配CPU和外设的速度差异
- 地址译码和读写控制逻辑
- 中断/DMA请求逻辑模块

## 串行接口及应用

==串行通信==：数据发送方将并行数据转换成按照二进制数据位排列的串行形式的数据送到传输线上；数据接收方的串行接口接收到这些二进制位后，再将它们**转换成字节形式的并行数据**

<img src="汇编语言与接口设计.assets/image-20210621103421976.png" alt="image-20210621103421976" style="zoom:67%;" />

### 传送方式

- 单工
- 半双工
- 全双工

### 通信协议

- 异步：**无时钟信号**，面向**字符**，传送**不连续**

  存在开始位（0）和停止位（1），**低位在前高位在后**

  ![image-20221215144000811](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215144000811.png)

- 同步：收发双方同一个时钟信号，面向**比特**，传送**连续**



### RS-232C标准

RS-232C将

- -5～-15V规定为“1”（逻辑1电平）
- +5～+15V规定为“0”（逻辑0电平）

标准TTL（Transistor-Transistor Logic）

- 电平定义+2.4～+5V为高电平，表示逻辑1
- 0～0.4V为低电平，表示逻辑0。

### *可编程串行通信接口（8250）

通用异步收发传输器UART，8250标准，最大通信速率可达19200b/s

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215152253635.png" alt="image-20221215152253635" style="zoom:50%;" />

![image-20221215171844933](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215171844933.png)

共有11个寄存器：

#### 线路状态寄存器LSR（101，+5）

存储串行数据传送的状态

注意第0、5位

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215154056412.png" alt="image-20221215154056412" style="zoom:80%;" />



#### 线路控制寄存器LCR（011，+3）

指定异步通信数据格式

![image-20221215160212546](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215160212546.png)

#### 除数锁存器DLL/DLM

控制传输速率

$f_{工作时钟} = f_{基准时钟} \div 除数锁存器 = 波特率 × 16 $，其中，$f_{基准时钟}=1843200Hz$

那么有：
$$
除数锁存器=115200\div波特率
$$
需要在对LCR最高位进行设置后再进行操作，将商的高字节写入DLM，低字节写入DLL，结束操作后需要**恢复LCR最高位为0**

> **设置波特率为2400b/s：**
>
> 根据上面的公式得到除数锁存器要设定为48也就是0030H
>
> ```assembly
> MOV		DX,3FBH			;置LCR口地址
> MOV		AL,80H			;DLAB=1
> OUT		DX,AL			;之后，3F8H、3F9H对应于DLL,DLM
> MOV		DX,3F8H			;DLL的I/O地址
> MOV		AL,30H			;
> OUT		DX,AL			;写入低8位
> MOV		DX,3F9H			;DLM的I/O地址
> MOV		AL,00H			;
> OUT		DX,AL			;写入高8位
> MOV		DX,3FBH			;LCR的I/O地址
> MOV		AL,00011111B	;
> OUT		DX,AL			;恢复LCR最高位，也就是DLAB=0
> ```

#### 其他

- 发送保持寄存器THR（000）

  保存CPU发送的数据字节

- 接收缓冲寄存器RBR（000）

  保存接收到的数据字节

## *定时和计数及其应用（8254）

计数和定时本质上是一致的，但计数的信号随机，计时的信号具有周期性

- 软件定时
- 不可编程的硬件定时
- **可编程的硬件定时**：可编程定时器芯片8254

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210621130601841.png" alt="image-20210621130601841" style="zoom: 67%;" /><img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215174330730.png" alt="image-20221215174330730" style="zoom:67%;" />

8254内部结构

- 数据总线缓冲器
- 读写逻辑
- 控制字寄存器
- 三个计数器，自带16位减法寄存器

寻址方式：共4个地址，分别代表计数器0、1、2和控制寄存器

### 控制寄存器

![image-20221215174545463](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215174545463.png)

#### 写操作示例

假设8254地址为40H-43H，试编写程序将计数器0初始化为工作方式3，采用二进制计数模式，计数初值为2000：

首先计算控制字：00110110=36H，初值2000=07D0H

 ```assembly
 MOV		AL,36H
 OUT		43H,AL	;传入控制字
 MOV		AL,0D0H
 OUT		40H,AL	;写低8位
 MOV		AL,07H
 OUT		41H,AL	;写高8位
 ```

#### 读操作实例

假设8254地址为40H-43H，试编写程序锁存并读取计数器0的当前计数值：

首先计算控制字：00000110=06H

```assembly
MOV		AL,06H
OUT		43H,AL
IN		AL,40H	;读出低8位
MOV		AH,AL
IN		AL,40H	;读出高8位
XCHG	AH,AL	;AX=输出锁存器的16位值
```

### 计数方式

- 方式0：计数结束中断方式
- 方式1：可编程单稳态触发器
- 方式2：脉冲波发生器
- 方式3：方波发生器
- 方式4：软件触发选通方式
- 方式5：硬件触发选通方式

![image-20221215182320985](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215182320985.png)

### 8254应用

- **计数**

  使用了方式0，在计数到达后会引起中断。只需要设定一个初值，就能根据初值计数；在没有达到初值次事件时，CPU也可以锁存并读出计数值，获得事件的发生次数

- **分频**

  8254工作在方式2/3时，输出频率为输入频率的$1/N$，$N$为计数初值

  提供一个频率为10kHz的时钟信号，要求每隔100ms采集一次数据。对于一个10kHz时钟信号，其周期为1/10kHz=0.0001s=0.1ms。需要对它进行分频，生成一个周期为100ms的信号，频率为10Hz。计数器初值应设置为1000

- **级联**

  如果需要产生的分频信号的系数超过了最大计数范围（16位），需要对两个计数器进行级联，初值满足$N1×N2$





# Chapter 9 中断技术

## 中断概述

- 中断：使CPU中止正在执行的程序而转去处理特殊事件的操作
- 中断源：引起中断的事件

Intel系列微处理器的对外中断引脚包括**申请中断**的引脚（INTR和NMI），一个**响应中断**的引脚（INTA）；除此之外微处理器还有软件中断INT，INTO，INT3和BOUND

### 中断分类

在保护模式下，外部中断称为“中断”，内部中断称为“异常”

#### 中断（外部中断）

中断信号来自CPU外部

- 可屏蔽中断：INTR引脚接收，标志寄存器EFLAGS中的==IF标志==决定是否响应INTR的中断请求
- 不可屏蔽中断：NMI引脚接收

#### 异常

不可屏蔽

- 故障：特点是可排除，在引起异常的指令之前，把异常情况通知给系统的一种情况

- 陷阱：在引起异常的指令执行之后触发，比如软中断INT n

- 终止：系统出现严重不可恢复事件后触发，系统必须重启才可恢复正常

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210621151118610.png" alt="image-20210621151118610" style="zoom:67%;" />

##### 部分重要的内部中断

- 除法出错中断 00

  除数等于0，故障

- 单步中断 01

  TF标志为1，处于单步运行模式，每执行一步自动产生中断，陷阱

- 断点中断 03

  调试使用，INT3，陷阱

- 溢出中断 04

  OF标志置1，执行INTO指令时产生中断，陷阱

- 指令中断 INT n

## 实模式处理过程

### 中断向量表

CPU根据获得**中断类型号作为索引**，在中断向量表中寻找中断服务程序的入口

中断向量表位于存储器00000H-003FFH单元，占据了1024个字节，每个中断向量占据**4个字节**，包含了中断服务程序的段地址和偏移量

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215220558588.png" alt="image-20221215220558588" style="zoom:50%;" />

> 给出以下中断表，得到INT 8H对应中断服务程序的段基址和偏移量：
>
> 0000:0000	68 10 A7 00 BB 13 73 05 - 16 00 98 03 B1 13 73 05
>
> 0000:0010	8B 01 70 00 B9 06 0E 02 - 40 07 0E 02 FF 03 0E 02
>
> 0000:0020	46 07 0E 02 0A 04 0E 02 - 3A 00 98 03 54 00 98 03
>
> 0000:0030	6E 00 98 03 88 00 98 03 - A2 00 98 03 FF 03 0E 02
>
> 1. 中断号为8，那么其中断向量位于0020H处，也就是：46 07 0E 02
> 2. 那么得到 020E:0746 即为中断服务程序的段基址和偏移量

### 中断处理过程

- 标志寄存器内容压栈
- 清楚中断标志IF和陷阱标志TF，禁止可频闭中断等功能
- 查找中断向量表，获取中断服务程序段地址和偏移量，修改CS和IP
- 执行中断服务程序
- 执行到IRET时，恢复状态

### 写中断向量表

可添加新的中断到中断向量表

## 保护模式中断处理

保护模式使用==中断描述符表==存储中断向量

### 中断描述符表IDT

每个CPU核具有一个唯一的IDT，位置不定，IDTR指明了IDT的位置和限长

IDT包含的描述符是中断门、陷阱门和任务门，其格式参考如下，8个字节，其中段选择符和偏移指明了中断服务程序的入口地址

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20210622092938991.png" alt="image-20210622092938991" style="zoom:50%;" />

### 中断和异常响应步骤

-  如果是异常处理，首先根据异常类型确定返回地址(CS:EIP)；对于故障，CS:EIP指向引起故障的指令；对于陷阱，CS:EIP指向引起陷阱的指令的下一条指令
- 判断中断类型号要索引的门描述符是否超出IDT的界限
- 再从IDT中取得对应的门描述符，分解出选择符、偏移量和属性节，并进行有关检查
- 根据门描述符类型，分别转入中断或异常处理程序

## *可编程控制器8259

可管理**8个硬件中断**

<img src="汇编语言与接口设计.assets/image-20210621154331547.png" alt="image-20210621154331547" style="zoom:50%;" />

- 右侧8根中断请求线
- INT：连接微处理器INTR
- INTA：连接中断处理器INTA

### 中断过程

- 当一条或多条中断请求线IR0～IR7变高时，设置相应的IRR位为1
- PR对中断优先权和中断屏蔽寄存器的状态进行判断，请求中断服务
- CPU响应中断时，送出中断响应信号$\overline {INTA}$，响应第一个$\overline {INTA}$信号时，将当前中断服务寄存器中相应位置位，并把IRR中相应位复位。第二个$\overline {INTA}$负脉冲期间，中断类型码被读入CPU。

#### 工作流程示例

（假设优先级从0-7由高到低）

- IR2出现中断请求，该引脚的对应的中断屏蔽字相应位为0，即没有被屏蔽。此时由于ISR全为0，没有比它的优先级更高的中断正在执行，IR2 的请求被送往CPU
- CPU响应中断时，8259将ISR的值变为00000100B，标志IR2正在被服务
- 假定IR7出现中断请求。由于IR2比IR7优先级更高，此请求暂时被忽略
- 假定IR1出现中断请求。由于IR1比IR2优先级更高，此请求被送往CPU
- CPU响应中断时，8259将ISR的值变为00000110B，标志IR2被中断，IR1 正在被服务

### 级联

n片8259级联能够支持的最大中断源数目为$8\times(n-1)+9-n=7n+1$

CAS2～CAS0：级联信号。由多片8259构成的主从结构中，只有一个主片，一 个或多个从片，从片最多有8个。主片和从片的CAS2～CAS0全部对应相连， 在中断响应时主片发送从片的标识码（0~7）。在第2个INTA#脉冲期间，只有 标识码匹配的从片才把中断类型码送至数据总线。

![image-20221215223838872](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215223838872.png)

### 8259编程

8259是根据收到CPU的命令字工作的，其分为==初始化命令字==和==操作命令字==

- 初始化命令字在系统启动时，由初始化程序设置，一旦设定，一般在系统工作过程中就不再改变
- 操作命令字是在计算机系统运行过程中，由CPU利用这些控制字来控制8259执行不同的操作，可在初始化之后的任何时刻写入8259，并可多次设置

![image-20221215224815360](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215224815360.png)

#### 初始化命令字

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215224916673.png" alt="image-20221215224916673" style="zoom: 80%;" />

##### ICW1

应写入偶地址端口

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215230126332.png" alt="image-20221215230126332" style="zoom: 80%;" />

##### ICW2

应写入奇地址端口

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215230150419.png" alt="image-20221215230150419" style="zoom: 67%;" />

##### ICW3

只有系统中有多片8259级联时，才需要设置ICW3；并且主片与从片的ICW3设置也不同：

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215230156809.png" alt="image-20221215230156809" style="zoom: 80%;" />

##### ICW4

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215230204175.png" alt="image-20221215230204175" style="zoom:80%;" />

#### 操作命令字

##### 中断屏蔽OCW1

实现对中断源的屏蔽功能

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215230405374.png" alt="image-20221215230405374" style="zoom:67%;" />

##### 优先级循环方式和中断结束方式OCW2

应写入偶地址端口

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215230433864.png" alt="image-20221215230433864" style="zoom:80%;" />

##### 特殊屏蔽方式和中断查询方式OCW3

应写入偶地址端口

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215230442597.png" alt="image-20221215230442597" style="zoom:80%;" />

#### 命令字小结

8259一共有7个命令字：ICW1～ICW4、OCW1～OCW3

ICW1、OCW2、 OCW3 写入偶地址端口（A0=0）, 标志位D4、D3对它们进行区分；其他写入奇地址端口

<img src="https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/image-20221215230334398.png" alt="image-20221215230334398" style="zoom:80%;" />
